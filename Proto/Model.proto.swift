// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file Model.proto

import Foundation
import ProtocolBuffers


public func == (lhs: User, rhs: User) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUsername == rhs.hasUsername) && (!lhs.hasUsername || lhs.username == rhs.username)
  fieldCheck = fieldCheck && (lhs.hasUserid == rhs.hasUserid) && (!lhs.hasUserid || lhs.userid == rhs.userid)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Message_, rhs: Message_) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUserid == rhs.hasUserid) && (!lhs.hasUserid || lhs.userid == rhs.userid)
  fieldCheck = fieldCheck && (lhs.hasMessage_ == rhs.hasMessage_) && (!lhs.hasMessage_ || lhs.message_ == rhs.message_)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Messages, rhs: Messages) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.messages == rhs.messages)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: LoginResponse, rhs: LoginResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasToken == rhs.hasToken) && (!lhs.hasToken || lhs.token == rhs.token)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Users, rhs: Users) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.users == rhs.users)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Room, rhs: Room) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.users == rhs.users)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasImage == rhs.hasImage) && (!lhs.hasImage || lhs.image == rhs.image)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct ModelRoot {
  public static var sharedInstance : ModelRoot {
   struct Static {
       static let instance : ModelRoot = ModelRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final public class User : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var username:String = ""

  public private(set) var hasUsername:Bool = false
  public private(set) var userid:Int32 = Int32(0)

  public private(set) var hasUserid:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasUsername {
      return false
    }
    if !hasUserid {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasUsername {
      try output.writeString(1, value:username)
    }
    if hasUserid {
      try output.writeInt32(2, value:userid)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUsername {
      serialize_size += username.computeStringSize(1)
    }
    if hasUserid {
      serialize_size += userid.computeInt32Size(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<User> {
    var mergedArray = Array<User>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> User? {
    return try User.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> User {
    return try User.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> User {
    return try User.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> User {
    return try User.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> User {
    return try User.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> User {
    return try User.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> User {
    return try User.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> User.Builder {
    return User.classBuilder() as! User.Builder
  }
  public func getBuilder() -> User.Builder {
    return classBuilder() as! User.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return User.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return User.Builder()
  }
  public func toBuilder() throws -> User.Builder {
    return try User.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:User) throws -> User.Builder {
    return try User.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasUsername {
      output += "\(indent) username: \(username) \n"
    }
    if hasUserid {
      output += "\(indent) userid: \(userid) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUsername {
             hashCode = (hashCode &* 31) &+ username.hashValue
          }
          if hasUserid {
             hashCode = (hashCode &* 31) &+ userid.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "User"
  }
  override public func className() -> String {
      return "User"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return User.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:User = User()
    public func getMessage() -> User {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUsername:Bool {
         get {
              return builderResult.hasUsername
         }
    }
    public var username:String {
         get {
              return builderResult.username
         }
         set (value) {
             builderResult.hasUsername = true
             builderResult.username = value
         }
    }
    public func setUsername(value:String) -> User.Builder {
      self.username = value
      return self
    }
    public func clearUsername() -> User.Builder{
         builderResult.hasUsername = false
         builderResult.username = ""
         return self
    }
    public var hasUserid:Bool {
         get {
              return builderResult.hasUserid
         }
    }
    public var userid:Int32 {
         get {
              return builderResult.userid
         }
         set (value) {
             builderResult.hasUserid = true
             builderResult.userid = value
         }
    }
    public func setUserid(value:Int32) -> User.Builder {
      self.userid = value
      return self
    }
    public func clearUserid() -> User.Builder{
         builderResult.hasUserid = false
         builderResult.userid = Int32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> User.Builder {
      builderResult = User()
      return self
    }
    public override func clone() throws -> User.Builder {
      return try User.builderWithPrototype(builderResult)
    }
    public override func build() throws -> User {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> User {
      let returnMe:User = builderResult
      return returnMe
    }
    public func mergeFrom(other:User) throws -> User.Builder {
      if other == User() {
       return self
      }
      if other.hasUsername {
           username = other.username
      }
      if other.hasUserid {
           userid = other.userid
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> User.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> User.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          username = try input.readString()

        case 16 :
          userid = try input.readInt32()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Message_ : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var userid:Int32 = Int32(0)

  public private(set) var hasUserid:Bool = false
  public private(set) var message_:String = ""

  public private(set) var hasMessage_:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasUserid {
      return false
    }
    if !hasMessage_ {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasUserid {
      try output.writeInt32(1, value:userid)
    }
    if hasMessage_ {
      try output.writeString(2, value:message_)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUserid {
      serialize_size += userid.computeInt32Size(1)
    }
    if hasMessage_ {
      serialize_size += message_.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Message_> {
    var mergedArray = Array<Message_>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Message_? {
    return try Message_.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Message_ {
    return try Message_.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Message_ {
    return try Message_.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Message_ {
    return try Message_.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Message_ {
    return try Message_.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Message_ {
    return try Message_.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Message_ {
    return try Message_.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Message_.Builder {
    return Message_.classBuilder() as! Message_.Builder
  }
  public func getBuilder() -> Message_.Builder {
    return classBuilder() as! Message_.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Message_.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Message_.Builder()
  }
  public func toBuilder() throws -> Message_.Builder {
    return try Message_.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Message_) throws -> Message_.Builder {
    return try Message_.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasUserid {
      output += "\(indent) userid: \(userid) \n"
    }
    if hasMessage_ {
      output += "\(indent) message_: \(message_) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUserid {
             hashCode = (hashCode &* 31) &+ userid.hashValue
          }
          if hasMessage_ {
             hashCode = (hashCode &* 31) &+ message_.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Message_"
  }
  override public func className() -> String {
      return "Message_"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Message_.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Message_ = Message_()
    public func getMessage() -> Message_ {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUserid:Bool {
         get {
              return builderResult.hasUserid
         }
    }
    public var userid:Int32 {
         get {
              return builderResult.userid
         }
         set (value) {
             builderResult.hasUserid = true
             builderResult.userid = value
         }
    }
    public func setUserid(value:Int32) -> Message_.Builder {
      self.userid = value
      return self
    }
    public func clearUserid() -> Message_.Builder{
         builderResult.hasUserid = false
         builderResult.userid = Int32(0)
         return self
    }
    public var hasMessage_:Bool {
         get {
              return builderResult.hasMessage_
         }
    }
    public var message_:String {
         get {
              return builderResult.message_
         }
         set (value) {
             builderResult.hasMessage_ = true
             builderResult.message_ = value
         }
    }
    public func setMessage_(value:String) -> Message_.Builder {
      self.message_ = value
      return self
    }
    public func clearMessage_() -> Message_.Builder{
         builderResult.hasMessage_ = false
         builderResult.message_ = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Message_.Builder {
      builderResult = Message_()
      return self
    }
    public override func clone() throws -> Message_.Builder {
      return try Message_.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Message_ {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Message_ {
      let returnMe:Message_ = builderResult
      return returnMe
    }
    public func mergeFrom(other:Message_) throws -> Message_.Builder {
      if other == Message_() {
       return self
      }
      if other.hasUserid {
           userid = other.userid
      }
      if other.hasMessage_ {
           message_ = other.message_
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Message_.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Message_.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          userid = try input.readInt32()

        case 18 :
          message_ = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Messages : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var messages:Array<Message_>  = Array<Message_>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitmessages:Bool = true
    for oneElementmessages in messages {
        if (!oneElementmessages.isInitialized()) {
            isInitmessages = false
            break 
        }
    }
    if !isInitmessages {
     return isInitmessages
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    for oneElementmessages in messages {
        try output.writeMessage(1, value:oneElementmessages)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementmessages in messages {
        serialize_size += oneElementmessages.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Messages> {
    var mergedArray = Array<Messages>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Messages? {
    return try Messages.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Messages {
    return try Messages.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Messages {
    return try Messages.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Messages {
    return try Messages.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Messages {
    return try Messages.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Messages {
    return try Messages.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Messages {
    return try Messages.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Messages.Builder {
    return Messages.classBuilder() as! Messages.Builder
  }
  public func getBuilder() -> Messages.Builder {
    return classBuilder() as! Messages.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Messages.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Messages.Builder()
  }
  public func toBuilder() throws -> Messages.Builder {
    return try Messages.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Messages) throws -> Messages.Builder {
    return try Messages.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    var messagesElementIndex:Int = 0
    for oneElementmessages in messages {
        output += "\(indent) messages[\(messagesElementIndex)] {\n"
        output += try oneElementmessages.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        messagesElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementmessages in messages {
              hashCode = (hashCode &* 31) &+ oneElementmessages.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Messages"
  }
  override public func className() -> String {
      return "Messages"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Messages.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Messages = Messages()
    public func getMessage() -> Messages {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var messages:Array<Message_> {
         get {
             return builderResult.messages
         }
         set (value) {
             builderResult.messages = value
         }
    }
    public func setMessages(value:Array<Message_>) -> Messages.Builder {
      self.messages = value
      return self
    }
    public func clearMessages() -> Messages.Builder {
      builderResult.messages.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Messages.Builder {
      builderResult = Messages()
      return self
    }
    public override func clone() throws -> Messages.Builder {
      return try Messages.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Messages {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Messages {
      let returnMe:Messages = builderResult
      return returnMe
    }
    public func mergeFrom(other:Messages) throws -> Messages.Builder {
      if other == Messages() {
       return self
      }
      if !other.messages.isEmpty  {
         builderResult.messages += other.messages
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Messages.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Messages.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder = Message_.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          messages += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class LoginResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var token:String = ""

  public private(set) var hasToken:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasToken {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasToken {
      try output.writeString(1, value:token)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasToken {
      serialize_size += token.computeStringSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<LoginResponse> {
    var mergedArray = Array<LoginResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> LoginResponse? {
    return try LoginResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> LoginResponse.Builder {
    return LoginResponse.classBuilder() as! LoginResponse.Builder
  }
  public func getBuilder() -> LoginResponse.Builder {
    return classBuilder() as! LoginResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return LoginResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return LoginResponse.Builder()
  }
  public func toBuilder() throws -> LoginResponse.Builder {
    return try LoginResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:LoginResponse) throws -> LoginResponse.Builder {
    return try LoginResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasToken {
      output += "\(indent) token: \(token) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasToken {
             hashCode = (hashCode &* 31) &+ token.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "LoginResponse"
  }
  override public func className() -> String {
      return "LoginResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return LoginResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:LoginResponse = LoginResponse()
    public func getMessage() -> LoginResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasToken:Bool {
         get {
              return builderResult.hasToken
         }
    }
    public var token:String {
         get {
              return builderResult.token
         }
         set (value) {
             builderResult.hasToken = true
             builderResult.token = value
         }
    }
    public func setToken(value:String) -> LoginResponse.Builder {
      self.token = value
      return self
    }
    public func clearToken() -> LoginResponse.Builder{
         builderResult.hasToken = false
         builderResult.token = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> LoginResponse.Builder {
      builderResult = LoginResponse()
      return self
    }
    public override func clone() throws -> LoginResponse.Builder {
      return try LoginResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> LoginResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> LoginResponse {
      let returnMe:LoginResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:LoginResponse) throws -> LoginResponse.Builder {
      if other == LoginResponse() {
       return self
      }
      if other.hasToken {
           token = other.token
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> LoginResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LoginResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          token = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Users : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var users:Array<User>  = Array<User>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitusers:Bool = true
    for oneElementusers in users {
        if (!oneElementusers.isInitialized()) {
            isInitusers = false
            break 
        }
    }
    if !isInitusers {
     return isInitusers
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    for oneElementusers in users {
        try output.writeMessage(1, value:oneElementusers)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementusers in users {
        serialize_size += oneElementusers.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Users> {
    var mergedArray = Array<Users>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Users? {
    return try Users.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Users {
    return try Users.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Users {
    return try Users.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Users {
    return try Users.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Users {
    return try Users.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Users {
    return try Users.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Users {
    return try Users.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Users.Builder {
    return Users.classBuilder() as! Users.Builder
  }
  public func getBuilder() -> Users.Builder {
    return classBuilder() as! Users.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Users.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Users.Builder()
  }
  public func toBuilder() throws -> Users.Builder {
    return try Users.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Users) throws -> Users.Builder {
    return try Users.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    var usersElementIndex:Int = 0
    for oneElementusers in users {
        output += "\(indent) users[\(usersElementIndex)] {\n"
        output += try oneElementusers.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        usersElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementusers in users {
              hashCode = (hashCode &* 31) &+ oneElementusers.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Users"
  }
  override public func className() -> String {
      return "Users"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Users.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Users = Users()
    public func getMessage() -> Users {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var users:Array<User> {
         get {
             return builderResult.users
         }
         set (value) {
             builderResult.users = value
         }
    }
    public func setUsers(value:Array<User>) -> Users.Builder {
      self.users = value
      return self
    }
    public func clearUsers() -> Users.Builder {
      builderResult.users.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Users.Builder {
      builderResult = Users()
      return self
    }
    public override func clone() throws -> Users.Builder {
      return try Users.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Users {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Users {
      let returnMe:Users = builderResult
      return returnMe
    }
    public func mergeFrom(other:Users) throws -> Users.Builder {
      if other == Users() {
       return self
      }
      if !other.users.isEmpty  {
         builderResult.users += other.users
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Users.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Users.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder = User.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          users += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Room : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var users:Array<User>  = Array<User>()
  public private(set) var name:String = ""

  public private(set) var hasName:Bool = false
  public private(set) var image:String = ""

  public private(set) var hasImage:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitusers:Bool = true
    for oneElementusers in users {
        if (!oneElementusers.isInitialized()) {
            isInitusers = false
            break 
        }
    }
    if !isInitusers {
     return isInitusers
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    for oneElementusers in users {
        try output.writeMessage(1, value:oneElementusers)
    }
    if hasName {
      try output.writeString(2, value:name)
    }
    if hasImage {
      try output.writeString(3, value:image)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementusers in users {
        serialize_size += oneElementusers.computeMessageSize(1)
    }
    if hasName {
      serialize_size += name.computeStringSize(2)
    }
    if hasImage {
      serialize_size += image.computeStringSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Room> {
    var mergedArray = Array<Room>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Room? {
    return try Room.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Room {
    return try Room.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Room {
    return try Room.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Room {
    return try Room.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Room {
    return try Room.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Room {
    return try Room.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Room {
    return try Room.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Room.Builder {
    return Room.classBuilder() as! Room.Builder
  }
  public func getBuilder() -> Room.Builder {
    return classBuilder() as! Room.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Room.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Room.Builder()
  }
  public func toBuilder() throws -> Room.Builder {
    return try Room.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Room) throws -> Room.Builder {
    return try Room.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    var usersElementIndex:Int = 0
    for oneElementusers in users {
        output += "\(indent) users[\(usersElementIndex)] {\n"
        output += try oneElementusers.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        usersElementIndex += 1
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasImage {
      output += "\(indent) image: \(image) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementusers in users {
              hashCode = (hashCode &* 31) &+ oneElementusers.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasImage {
             hashCode = (hashCode &* 31) &+ image.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Room"
  }
  override public func className() -> String {
      return "Room"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Room.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Room = Room()
    public func getMessage() -> Room {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var users:Array<User> {
         get {
             return builderResult.users
         }
         set (value) {
             builderResult.users = value
         }
    }
    public func setUsers(value:Array<User>) -> Room.Builder {
      self.users = value
      return self
    }
    public func clearUsers() -> Room.Builder {
      builderResult.users.removeAll(keepCapacity: false)
      return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String) -> Room.Builder {
      self.name = value
      return self
    }
    public func clearName() -> Room.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasImage:Bool {
         get {
              return builderResult.hasImage
         }
    }
    public var image:String {
         get {
              return builderResult.image
         }
         set (value) {
             builderResult.hasImage = true
             builderResult.image = value
         }
    }
    public func setImage(value:String) -> Room.Builder {
      self.image = value
      return self
    }
    public func clearImage() -> Room.Builder{
         builderResult.hasImage = false
         builderResult.image = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Room.Builder {
      builderResult = Room()
      return self
    }
    public override func clone() throws -> Room.Builder {
      return try Room.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Room {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Room {
      let returnMe:Room = builderResult
      return returnMe
    }
    public func mergeFrom(other:Room) throws -> Room.Builder {
      if other == Room() {
       return self
      }
      if !other.users.isEmpty  {
         builderResult.users += other.users
      }
      if other.hasName {
           name = other.name
      }
      if other.hasImage {
           image = other.image
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Room.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Room.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder = User.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          users += [subBuilder.buildPartial()]

        case 18 :
          name = try input.readString()

        case 26 :
          image = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}


// @@protoc_insertion_point(global_scope)
